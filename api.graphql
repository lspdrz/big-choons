### This file was generated by Nexus Schema
### Do not make changes to this file directly


type BatchPayload {
  count: Int!
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
`date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar Json

enum MediaService {
  APPLE_MUSIC
  SOUNDCLOUD
  SPOTIFY
  YOUTUBE
}

type Mutation {
  bigRedButton: String
  createOneUser(data: UserCreateInput!): User!
  deleteManyUser(where: UserWhereInput): BatchPayload!
  deleteOneUser(where: UserWhereUniqueInput!): User
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Query {
  allUsers: [User!]
  user(where: UserWhereUniqueInput!): User
  users(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int): [User!]!
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input TrackCreateOneWithoutLikesInput {
  connect: TrackWhereUniqueInput
  create: TrackCreateWithoutLikesInput
}

input TrackCreateWithoutLikesInput {
  createdAt: DateTime
  notes: String
  source: String!
  title: String!
  type: MediaService
  updatedAt: DateTime
}

input TrackUpdateOneWithoutLikesInput {
  connect: TrackWhereUniqueInput
  create: TrackCreateWithoutLikesInput
  delete: Boolean
  disconnect: Boolean
  update: TrackUpdateWithoutLikesDataInput
  upsert: TrackUpsertWithoutLikesInput
}

input TrackUpdateWithoutLikesDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  notes: NullableStringFieldUpdateOperationsInput
  source: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  type: MediaService
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TrackUpsertWithoutLikesInput {
  create: TrackCreateWithoutLikesInput!
  update: TrackUpdateWithoutLikesDataInput!
}

input TrackWhereInput {
  AND: [TrackWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  likes: UserListRelationFilter
  NOT: [TrackWhereInput!]
  notes: StringNullableFilter
  OR: [TrackWhereInput!]
  source: StringFilter
  title: StringFilter
  type: MediaService
  updatedAt: DateTimeFilter
}

input TrackWhereUniqueInput {
  id: Int
}

type User {
  id: Int!
  name: String!
}

input UserCreateInput {
  createdAt: DateTime
  email: String!
  followedBy: UserCreateManyWithoutFollowingInput
  following: UserCreateManyWithoutFollowedByInput
  name: String!
  track: TrackCreateOneWithoutLikesInput
  updatedAt: DateTime
  username: String!
}

input UserCreateManyWithoutFollowedByInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutFollowedByInput!]
}

input UserCreateManyWithoutFollowingInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutFollowingInput!]
}

input UserCreateWithoutFollowedByInput {
  createdAt: DateTime
  email: String!
  following: UserCreateManyWithoutFollowedByInput
  name: String!
  track: TrackCreateOneWithoutLikesInput
  updatedAt: DateTime
  username: String!
}

input UserCreateWithoutFollowingInput {
  createdAt: DateTime
  email: String!
  followedBy: UserCreateManyWithoutFollowingInput
  name: String!
  track: TrackCreateOneWithoutLikesInput
  updatedAt: DateTime
  username: String!
}

input UserListRelationFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

input UserScalarWhereInput {
  AND: [UserScalarWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  id: IntFilter
  name: StringFilter
  NOT: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  trackId: IntNullableFilter
  updatedAt: DateTimeFilter
  username: StringFilter
}

input UserUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  followedBy: UserUpdateManyWithoutFollowingInput
  following: UserUpdateManyWithoutFollowedByInput
  name: StringFieldUpdateOperationsInput
  track: TrackUpdateOneWithoutLikesInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
}

input UserUpdateManyDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
}

input UserUpdateManyWithoutFollowedByInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutFollowedByInput!]
  delete: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutFollowedByInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutFollowedByInput!]
}

input UserUpdateManyWithoutFollowingInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutFollowingInput!]
  delete: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutFollowingInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutFollowingInput!]
}

input UserUpdateManyWithWhereNestedInput {
  data: UserUpdateManyDataInput!
  where: UserScalarWhereInput!
}

input UserUpdateWithoutFollowedByDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  following: UserUpdateManyWithoutFollowedByInput
  name: StringFieldUpdateOperationsInput
  track: TrackUpdateOneWithoutLikesInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
}

input UserUpdateWithoutFollowingDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  followedBy: UserUpdateManyWithoutFollowingInput
  name: StringFieldUpdateOperationsInput
  track: TrackUpdateOneWithoutLikesInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
}

input UserUpdateWithWhereUniqueWithoutFollowedByInput {
  data: UserUpdateWithoutFollowedByDataInput!
  where: UserWhereUniqueInput!
}

input UserUpdateWithWhereUniqueWithoutFollowingInput {
  data: UserUpdateWithoutFollowingDataInput!
  where: UserWhereUniqueInput!
}

input UserUpsertWithWhereUniqueWithoutFollowedByInput {
  create: UserCreateWithoutFollowedByInput!
  update: UserUpdateWithoutFollowedByDataInput!
  where: UserWhereUniqueInput!
}

input UserUpsertWithWhereUniqueWithoutFollowingInput {
  create: UserCreateWithoutFollowingInput!
  update: UserUpdateWithoutFollowingDataInput!
  where: UserWhereUniqueInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  followedBy: UserListRelationFilter
  following: UserListRelationFilter
  id: IntFilter
  name: StringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  track: TrackWhereInput
  trackId: IntNullableFilter
  updatedAt: DateTimeFilter
  username: StringFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
}
